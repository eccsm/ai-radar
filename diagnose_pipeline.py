#!/usr/bin/env python
"""
AI Radar Pipeline Diagnostic Tool

This script tests the entire AI Radar pipeline by:
1. Connecting to NATS
2. Publishing test messages
3. Checking the database for results
4. Testing S3/MinIO connectivity

Run this script from your host machine to diagnose container issues.
"""
import asyncio
import json
import os
import time
import sys
from datetime import datetime, timedelta
import uuid

# Install required packages if not present
try:
    import nats
    import aioboto3
    import asyncpg
    import tenacity
except ImportError:
    print("Installing required packages...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", 
                          "nats-py", "aioboto3", "asyncpg", "tenacity"])
    import nats
    import aioboto3
    import asyncpg
    import tenacity

# Configuration
NATS_URL = "nats://localhost:4222"  # Using localhost since we're running outside container
POSTGRES_URL = "postgresql://ai:ai_pwd@localhost:5432/ai_radar"
MINIO_URL = "http://localhost:9000"
BUCKET_NAME = "ai-radar-content"
MINIO_ROOT_USER = "minio"
MINIO_ROOT_PASSWORD = "minio_pwd"

from tenacity import retry, stop_after_attempt, wait_exponential

class DiagnosticTool:
    def __init__(self):
        self.nats_client = None
        self.js = None
        self.db_conn = None
        self.s3_client = None
        self.test_id = str(uuid.uuid4())[:8]  # Generate a unique ID for this test run
    
    async def connect_nats(self):
        """Connect to NATS server"""
        print(f"[NATS] Connecting to {NATS_URL}...")
        try:
            self.nats_client = await nats.connect(NATS_URL)
            self.js = self.nats_client.jetstream()
            print(f"[NATS] ✅ Connected successfully")
            return True
        except Exception as e:
            print(f"[NATS] ❌ Connection failed: {str(e)}")
            return False

    async def connect_postgres(self):
        """Connect to PostgreSQL database"""
        print(f"[DB] Connecting to {POSTGRES_URL}...")
        try:
            self.db_conn = await asyncpg.connect(POSTGRES_URL)
            # Test connection with a simple query
            version = await self.db_conn.fetchval("SELECT version()")
            print(f"[DB] ✅ Connected successfully: {version}")
            return True
        except Exception as e:
            print(f"[DB] ❌ Connection failed: {str(e)}")
            return False
    
    async def connect_minio(self):
        """Connect to MinIO/S3"""
        print(f"[S3] Connecting to {MINIO_URL}...")
        try:
            session = aioboto3.Session()
            self.s3_client = session.client(
                service_name="s3",
                endpoint_url=MINIO_URL,
                aws_access_key_id=MINIO_ROOT_USER,
                aws_secret_access_key=MINIO_ROOT_PASSWORD,
            )
            # Test connection by listing buckets
            async with self.s3_client as s3:
                response = await s3.list_buckets()
                buckets = [bucket['Name'] for bucket in response['Buckets']]
                if BUCKET_NAME in buckets:
                    print(f"[S3] ✅ Connected successfully, found bucket '{BUCKET_NAME}'")
                else:
                    print(f"[S3] ⚠️ Connected, but bucket '{BUCKET_NAME}' not found. Available buckets: {buckets}")
            return True
        except Exception as e:
            print(f"[S3] ❌ Connection failed: {str(e)}")
            return False
    
    async def publish_test_article(self):
        """Publish a test article to NATS"""
        if not self.js:
            print("[NATS] Cannot publish: Not connected to NATS")
            return False
        
        try:
            # Create a test content file in S3
            test_content = f"""
            This is a test article generated by the diagnostic tool.
            Test ID: {self.test_id}
            Time: {datetime.now().isoformat()}
            
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor, 
            nisl nec ultricies lacinia, nisl nisl aliquet nisl, nec ultricies nisl
            nisl nec ultricies lacinia, nisl nisl aliquet nisl, nec ultricies nisl.
            
            This content should be processed by the summarizer agent.
            """
            
            content_key = f"test-articles/diagnostic-{self.test_id}.txt"
            
            # Upload to S3/MinIO - Create a new client for this operation
            print(f"[S3] Uploading test content to {content_key}...")
            session = aioboto3.Session()
            s3_client = session.client(
                service_name="s3",
                endpoint_url=MINIO_URL,
                aws_access_key_id=MINIO_ROOT_USER,
                aws_secret_access_key=MINIO_ROOT_PASSWORD,
            )
            
            async with s3_client as s3:
                await s3.put_object(
                    Bucket=BUCKET_NAME,
                    Key=content_key,
                    Body=test_content.encode()
                )
            print(f"[S3] ✅ Test content uploaded")
            
            # Create message for summarizer
            test_message = {
                "title": f"Diagnostic Test Article {self.test_id}",
                "url": f"https://example.com/test-article-{self.test_id}",
                "published_at": datetime.now().isoformat(),
                "content_key": content_key,
                "author": "Diagnostic Tool",
                "source_name": "Test Source",
                "source_url": "https://example.com",
                "timestamp": datetime.now().isoformat()
            }
            
            # Publish to summarizer subject
            print(f"[NATS] Publishing test message to ai-radar.tasks.summarize...")
            await self.js.publish(
                "ai-radar.tasks.summarize", 
                json.dumps(test_message).encode()
            )
            print(f"[NATS] ✅ Test message published")
            return True
            
        except Exception as e:
            print(f"[NATS] ❌ Failed to publish test message: {str(e)}")
            return False
    
    @retry(stop=stop_after_attempt(10), wait=wait_exponential(multiplier=1, min=2, max=10))
    async def check_article_in_db(self):
        """Check if the test article was processed and stored in the database"""
        if not self.db_conn:
            print("[DB] Cannot check: Not connected to database")
            return False
        
        try:
            # First, let's check the schema to understand the column names
            schema_query = """
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_schema = 'ai_radar' AND table_name = 'articles'
            ORDER BY ordinal_position
            """
            
            columns = await self.db_conn.fetch(schema_query)
            column_names = [col['column_name'] for col in columns]
            print(f"[DB] Found columns in ai_radar.articles: {', '.join(column_names)}")
            
            # Use a more resilient query that doesn't depend on specific column names
            # We know id, title, url, and summary should exist
            query = """
            SELECT id, title, url, summary, published_at
            FROM ai_radar.articles
            WHERE title LIKE $1
            ORDER BY id DESC
            LIMIT 1
            """
            
            article = await self.db_conn.fetchrow(
                query, f"%{self.test_id}%"
            )
            
            if article:
                print(f"[DB] ✅ Found article in database!")
                print(f"      ID: {article['id']}")
                print(f"      Title: {article['title']}")
                print(f"      URL: {article['url']}")
                print(f"      Published: {article['published_at']}")
                print(f"      Summary: {article['summary'][:100]}...")
                return True
            else:
                print(f"[DB] ⚠️ Test article not found in database yet")
                # Raise an exception to trigger retry
                raise RuntimeError("Article not found yet")
        
        except RuntimeError:
            # Re-raise for tenacity to retry
            raise
        except Exception as e:
            print(f"[DB] ❌ Error checking for article: {str(e)}")
            return False
    
    async def diagnose(self):
        """Run the full diagnostic"""
        print("=" * 60)
        print("AI RADAR PIPELINE DIAGNOSTIC TOOL")
        print("=" * 60)
        print(f"Test ID: {self.test_id}")
        print(f"Time: {datetime.now().isoformat()}")
        print("=" * 60)
        
        # Connect to services
        nats_ok = await self.connect_nats()
        db_ok = await self.connect_postgres()
        s3_ok = await self.connect_minio()
        
        if not nats_ok or not s3_ok:
            print("\n❌ Cannot proceed with publishing test: NATS or S3 connection failed")
            return
        
        # Publish test article
        publish_ok = await self.publish_test_article()
        
        if not publish_ok:
            print("\n❌ Failed to publish test article")
            return
        
        if not db_ok:
            print("\n⚠️ Cannot check database for results: DB connection failed")
            return
        
        # Wait and check for article in database
        print("\nWaiting for article to be processed...")
        print("This may take up to 2 minutes. Checking database every few seconds...")
        
        try:
            article_found = await self.check_article_in_db()
            if article_found:
                print("\n✅ SUCCESS! The pipeline is working correctly!")
            else:
                print("\n❌ Could not find the test article in the database after multiple attempts")
        except tenacity.RetryError:
            print("\n❌ Article not found in database after multiple attempts")
            print("\nPossible issues:")
            print("1. The summarizer agent is not receiving messages from NATS")
            print("2. The summarizer agent is receiving messages but failing to process them")
            print("3. The summarizer agent is processing messages but failing to store in database")
            print("\nCheck the logs for the summarizer agent for more details")
        
        # Cleanup
        if self.nats_client:
            await self.nats_client.close()
        if self.db_conn:
            await self.db_conn.close()
        
        print("\nDiagnostic complete.")

async def main():
    tool = DiagnosticTool()
    await tool.diagnose()

if __name__ == "__main__":
    asyncio.run(main())
